{
    "summary": "",
    "title": "异步编程碰上ES6",
    "list": ["JavaScript"]
}

====


## 多个异步事件的回调函数同时执行

假如有这么一个场景，前端er需要调用好多个后台接口，需综合所有的接口数据才能组成一套完整的数据，然后渲染到浏览器上。

这时，就需要对多个异步事件进行处理，下面以`timeout事件`模拟Ajax请求。

### 方法一：使用`Promist.all()`
```
function xhr(t){
    return new Promise(function(resolve,reject){
        console.log('start');
        setTimeout(function() {
            resolve('this is ' + t)
        }, t);
    })
}

var xhr1 = xhr(1000);
var xhr2 = xhr(5000);

Promise.all([xhr2,xhr1]).then(function(results){
    console.log(results)
})

```

> 执行结果为： 
- 立即打印 
```
ajax start
ajax start
```
- 5s后，打印 
```
[ 'this is 5000', 'this is 1000' ]
```



### 方法二：自己动手造轮子

**实现思路：** 维护一个事件队列，先进来的事件先执行。然后记录每个异步事件的时间，取最大者记作`max`，在所有事件添加到队列后即调用一个`run`函数时，设置`timeout`的延迟为`max`

```
function StartAll() {
    this.list = []
    this.max = -9999
    this.len = 0
}

StartAll.prototype = {
    task: function (n, callback) {
        this.list.push(callback)
        this.max = this.max <= n ? n : this.max
    },
    run: function () {
        var _this = this
        var out = setTimeout(function () {
            _this.list.forEach(function (fun) {
                fun()
            })
            clearTimeout(out)
        }, this.max);
    }
}

var all = new StartAll()
all.task(6000, function () {
    console.log('this is 6000')
});
all.task(6000, function () {
    console.log('this is 6000')
});
all.task(2000, function () {
    console.log('this is 2000')
});
all.task(3000, function () {
    console.log('this is 3000')
});

all.run();
```

> 执行结果为： 
- 立即打印 
```
ajax start
ajax start
ajax start
ajax start
```
- 6s后，打印 
```
this is 6000
this is 6000
this is 2000
this is 3000
```

## 使用Generator简化代码

获得某城市的天气预报的流程如下：
获得令牌 -> 获得城市 -> 获得具体信息

这是一个回调函数嵌套回调函数的代码段，用`Promise`后，可以让代码看起来同步化：

```
function fetch(url) {
    return new Promise(function (resolve) {
        var time = ~~(Math.random() * 1001) + 1000;
        setTimeout(function () {
            resolve(url + '- data - ' + time);
        }, time)
    })
}

fetch('token') // 请求token
.then(function(result){ 
    console.log(result); // token 响应
    return fetch('city'); // 拿到token后继续请求city
}).then(function(result){
    console.log(result); // city响应
    return fetch('detail'); // 拿到继续请求detail
}).then(function(result){
    console.log(result); // detail响应
})
```

如果使用`Generator`，代码会更加简洁：

```
var step = 1
function fetch(url) {
    var time = ~~(Math.random() * 1001) + 1000;
    setTimeout(function () {
        console.log(url + '- data - ' + time)
        s.next('step ' + step++);
    }, time)
}

function* fetch2() {
    var token = yield fetch('step '+step++) // token的值是第一次s.next(para)中的para值，也就是第一次回调函数的结果值
    var city = yield fetch(token) // city的值是第二次s.next(para)中的para值，也就是第二次回调函数的结果值
    yield fetch(city)
}

var s = fetch2();
s.next();
```
利用`next()`函数，可以传入上次请求的结果，实现`获得令牌 -> 获得城市 -> 获得具体信息`的请求流程

`next(x)`作用是：

1. 传入的参数`x`，作为上个阶段异步任务的返回结果；
2. 执行当前`yield`后面的代码。

> 执行结果为：

```
step 1- data - 1191
step 2- data - 1589
step 3- data - 1520
```

## Async初次尝试
> async 函数是什么？一句话，它就是 Generator 函数的语法糖。 
    --- 阮一峰老师《ES6标准入门》

使用`Generator`时，执行一个封装有很多个异步操作的函数时，需要调用`next`函数，若使用`Async`函数，则省去了这个步骤。

async函数返回一个 Promise 对象，async函数内部return语句返回的值，会成为then方法回调函数的参数。

```
async function f() {
  return 'hello world';
}

f().then(v => console.log(v))
// "hello world"
```

## 写在后面

不知道又会出现啥新的怪异需求，暂时先记录这么多。

关于ES6的新特性，还需要不断学习。