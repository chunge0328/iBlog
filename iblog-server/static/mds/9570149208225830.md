
{
    "summary": "",
    "title": "暑期实习记事2",
    "list": ["其他"]
}

====


## 完善了表单校验功能
1. 前端JS用正则检查表单输入的合法性，后端用PHP检查
2. 前端若出现不合格的输入时，在提交的时候会提示相应的*syslog*信息输入错误
3. 若后端还出现不合格的输入，有可能是恶意的人用代码提交的数据，则阻止它

## 初步学习了Angular1中的脏检查

### 概述

1. Angular1中的双向数据绑定，指的是从界面的操作能实时反映到数据，数据的变更能实时展现到界面。
2. 前者的实现原理大致是在事件发生时，更改对应的数据，比如`input事件`发生时，更改对应的`input`的`value`值 
3. 后者的实现原理大致在指定事件触发后，才进入$digest cycle，（即是在事件发生后，进行脏检查操作），$digest后批量更新UI。其中，指定事件包括以下：
    - DOM事件，譬如用户输入文本，点击按钮等。(ng-click)
    - XHR响应事件 ($http)
    - 浏览器Location变更事件 ($location)
    - Timer事件($timeout, $interval)
    - 执行$digest()或$apply()

### $watch 队列
每次绑定一些东西到你的UI上时你就会往$watch队列里插入一条$watch。$watch就是那个可以检测它监视的model里时候有变化的东西。

### $digest循环
1. 当上述的指定事件触发时，$digest循环便被触发
2. 这个循环由两个循环组成：一个处理evalAsync队列，另一个处理$watch队列
3. 下面对$watch队列详细说明

#### 所谓的dirty-checking（脏检查）
1. $digist会遍历刚才所说的$watch队列，检查它们是否改变，直到$watch队列里面的元素都检查完毕
2. 到这时，所有的$watch都检查完了，那就要问了：有没有$watch更新过？如果有至少一个更新过，这个循环就会再次触发，直到所有的$watch都没有变化
3. 记住如果循环超过10次的话，它将会抛出一个异常，防止无限循环。
4.  当$digest循环结束时，DOM相应地变化。

#### 上图
![](https://cloud.githubusercontent.com/assets/227713/5223551/56c772da-76f6-11e4-9a0d-a847072e91ac.png) 

### $apply的使用场景

假设有这样一个业务场景：

自定义的一个计数器的指令，当点击它时改变UI上的index值

这时候会发现，index变化了，UI却没有更新。。。

**原因在于：$scope确实改变了，但是没有强制$digest循环，监视index的$watch没有执行。所以这时候就需要手动调用$apply了**

所以只需要添加代码： `scope.$apply();`







